import{r as u,j as p,t as m}from"./app-5znjwuGY.js";function z(e,t,{checkForDefaultPrevented:o=!0}={}){return function(n){if(e?.(n),o===!1||!n.defaultPrevented)return t?.(n)}}function R(e,t){const o=u.createContext(t),i=c=>{const{children:s,...r}=c,f=u.useMemo(()=>r,Object.values(r));return p.jsx(o.Provider,{value:f,children:s})};i.displayName=e+"Provider";function n(c){const s=u.useContext(o);if(s)return s;if(t!==void 0)return t;throw new Error(`\`${c}\` must be used within \`${e}\``)}return[i,n]}function $(e,t=[]){let o=[];function i(c,s){const r=u.createContext(s),f=o.length;o=[...o,s];const d=a=>{const{scope:h,children:x,...v}=a,S=h?.[e]?.[f]||r,C=u.useMemo(()=>v,Object.values(v));return p.jsx(S.Provider,{value:C,children:x})};d.displayName=c+"Provider";function l(a,h){const x=h?.[e]?.[f]||r,v=u.useContext(x);if(v)return v;if(s!==void 0)return s;throw new Error(`\`${a}\` must be used within \`${c}\``)}return[d,l]}const n=()=>{const c=o.map(s=>u.createContext(s));return function(r){const f=r?.[e]||c;return u.useMemo(()=>({[`__scope${e}`]:{...r,[e]:f}}),[r,f])}};return n.scopeName=e,[i,w(n,...t)]}function w(...e){const t=e[0];if(e.length===1)return t;const o=()=>{const i=e.map(n=>({useScope:n(),scopeName:n.scopeName}));return function(c){const s=i.reduce((r,{useScope:f,scopeName:d})=>{const a=f(c)[`__scope${d}`];return{...r,...a}},{});return u.useMemo(()=>({[`__scope${t.scopeName}`]:s}),[s])}};return o.scopeName=t.scopeName,o}var b=globalThis?.document?u.useLayoutEffect:()=>{},E=m[" useInsertionEffect ".trim().toString()]||b;function j({prop:e,defaultProp:t,onChange:o=()=>{},caller:i}){const[n,c,s]=g({defaultProp:t,onChange:o}),r=e!==void 0,f=r?e:n;{const l=u.useRef(e!==void 0);u.useEffect(()=>{const a=l.current;a!==r&&console.warn(`${i} is changing from ${a?"controlled":"uncontrolled"} to ${r?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),l.current=r},[r,i])}const d=u.useCallback(l=>{if(r){const a=P(l)?l(e):l;a!==e&&s.current?.(a)}else c(l)},[r,e,c,s]);return[f,d]}function g({defaultProp:e,onChange:t}){const[o,i]=u.useState(e),n=u.useRef(o),c=u.useRef(t);return E(()=>{c.current=t},[t]),u.useEffect(()=>{n.current!==o&&(c.current?.(o),n.current=o)},[o,n]),[o,i,c]}function P(e){return typeof e=="function"}function _(e){const[t,o]=u.useState(void 0);return b(()=>{if(e){o({width:e.offsetWidth,height:e.offsetHeight});const i=new ResizeObserver(n=>{if(!Array.isArray(n)||!n.length)return;const c=n[0];let s,r;if("borderBoxSize"in c){const f=c.borderBoxSize,d=Array.isArray(f)?f[0]:f;s=d.inlineSize,r=d.blockSize}else s=e.offsetWidth,r=e.offsetHeight;o({width:s,height:r})});return i.observe(e,{box:"border-box"}),()=>i.unobserve(e)}else o(void 0)},[e]),t}function M(e){const t=u.useRef({value:e,previous:e});return u.useMemo(()=>(t.current.value!==e&&(t.current.previous=t.current.value,t.current.value=e),t.current.previous),[e])}export{z as a,b,$ as c,M as d,R as e,_ as f,j as u};
